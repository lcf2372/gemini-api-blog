<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring CI/CD and API Testing with the Gemini API</title>
    <style>
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #f8f9fa;
            color: #333;
            margin: 0;
            padding: 0;
        }
        header {
            background-color: #007bff;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        main {
            max-width: 800px;
            margin: 30px auto;
            background: #fff;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        h1 {
            font-size: 2.5rem;
        }
        h2 {
            font-size: 1.75rem;
            margin-top: 40px;
        }
        h3 {
            font-size: 1.25rem;
            margin-top: 30px;
        }
        p {
            font-size: 1rem;
            line-height: 1.8;
            margin: 15px 0;
        }
        pre, code {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow-x: auto;
        }
        pre {
            margin: 20px 0;
        }
        blockquote {
            font-style: italic;
            background-color: #f9f9f9;
            padding: 15px 20px;
            border-left: 4px solid #007bff;
            margin: 20px 0;
        }
        ul {
            padding-left: 20px;
        }
        ul li {
            margin: 10px 0;
        }
        .response {
            background-color: #dff0d8;
            border-left: 5px solid #3c763d;
            padding: 15px;
            border-radius: 8px;
        }
        footer {
            text-align: center;
            font-size: 0.9rem;
            margin-top: 30px;
            padding: 10px;
            color: #666;
        }
    </style>
</head>
<body>
<header>
    <h1>Exploring CI/CD and API Testing with the Gemini API</h1>
</header>
<main>
    <p>Building reliable, scalable applications is a key goal for developers, and one of the most effective ways to achieve this is by implementing a CI/CD (Continuous Integration/Continuous Deployment) pipeline. In this post, I’ll walk you through my journey of developing the Gemini API, testing it, and setting up an automated CI/CD pipeline using GitHub Actions. Along the way, I’ll explain how these tools streamline the development process and ensure that everything works seamlessly.</p>

    <h2>Setting Up the Gemini API</h2>
    <p>The Gemini API I created serves as a simple interface for generating content based on user-provided prompts and instructions. The idea behind the API is simple: users send a request with a prompt, and the API responds with a mock result based on that prompt. This allows for easy testing and showcases how APIs can be used to generate content programmatically.</p>
    <p>The API is built using Flask, a lightweight Python framework that’s perfect for quick, simple applications. We’ve set up a POST endpoint at <code>/generate</code> that accepts two pieces of information from users: a prompt and instructions. Based on this input, the API sends back a response with the processed data.</p>

    <h3>Here’s a quick look at the core function that handles incoming requests:</h3>
    <pre><code>@app.route('/generate', methods=['POST'])
def generate_content():
    data = request.get_json()
    prompt = data.get("prompt")
    instructions = data.get("instructions")
    response = f"This is a mock response based on the prompt: '{prompt}' with instructions: '{instructions}'."
    return jsonify({"response": response})</code></pre>

    <h2>Testing the API Locally</h2>
    <p>Before diving into the CI/CD setup, it’s crucial to make sure the API works as expected. To test it locally, I used <code>curl</code>, a simple yet powerful command-line tool that allows you to send HTTP requests and view responses.</p>
    <p>For example, I used the following curl command to send a POST request to the <code>/generate</code> endpoint:</p>

    <pre><code>curl -X POST http://localhost:5000/generate \
-H "Content-Type: application/json" \
-d "{\"prompt\": \"Write a blog post introduction\", \"instructions\": \"Make it formal and concise.\"}"</code></pre>
    <div class="response">
        <p>Response:</p>
        <pre><code>{
  "response": "This is a mock response based on the prompt: 'Write a blog post introduction' with instructions: 'Make it formal and concise.'"
}</code></pre>
    </div>
    <p>This gave me a mock response, proving that the basic functionality was in place.</p>

    <h2>Setting Up CI/CD with GitHub Actions</h2>
    <p>Once the API was working locally, the next step was to automate testing and integration with GitHub Actions. CI/CD pipelines are essential for automating the testing, building, and deployment processes. With GitHub Actions, I set up a pipeline that automatically triggers whenever changes are pushed to the repository.</p>
    <p>The pipeline is configured to do the following:</p>
    <ul>
        <li>Build the Docker Image: Docker ensures that the API runs the same way on any machine, eliminating environment inconsistencies.</li>
        <li>Run Tests: Although I’ve mocked the actual tests in the pipeline for now, this step will eventually run unit and integration tests automatically.</li>
        <li>CI/CD Automation: The entire process is automated — no more manual testing or deployment steps.</li>
    </ul>

    <h2>Challenges and Solutions</h2>
    <p>While setting up the pipeline, I encountered a few hurdles that required some problem-solving:</p>
    <ul>
        <li><strong>Running Docker in CI/CD:</strong> One challenge I faced was getting Docker to run properly inside the GitHub Actions environment. Docker containers are essential for this project, and initially, I had trouble with networking and connectivity between the containers.</li>
        <li><strong>Testing in Docker:</strong> Running API tests inside Docker was tricky because I needed to ensure the containerized environment mimicked the local setup accurately. For now, I’ve opted to mock the tests, but I plan to revisit this to fully automate the test process inside Docker.</li>
    </ul>
    <p>Despite these obstacles, GitHub Actions has proven to be a powerful tool, and with some adjustments, it will soon fully automate the testing and deployment processes.</p>

    <h2>Conclusion</h2>
    <p>In summary, this project provided valuable experience in working with APIs, Docker, and CI/CD pipelines. By integrating these tools, I was able to automate the process of testing and building the Gemini API, saving time and reducing the risk of human error.</p>
</main>
<footer>
    <p>Created by Abinesh Pandi | Exploring the Future of Development</p>
</footer>
</body>
</html>
