<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Exploring CI/CD and API Testing with the Gemini API">
    <title>Gemini API CI/CD Exploration</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        header {
            text-align: center;
            padding: 10px 0;
            background-color: #0073e6;
            color: white;
            border-radius: 5px;
        }
        h1 {
            margin-top: 0;
        }
        h2 {
            color: #0073e6;
            margin-top: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background: #e8e8e8;
            padding: 2px 4px;
            border-radius: 3px;
        }
        section {
            margin-bottom: 40px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        footer {
            text-align: center;
            font-size: 0.9em;
            margin-top: 20px;
            color: #666;
        }
        a {
            color: #0073e6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<header>
    <h1>Exploring CI/CD and API Testing with the Gemini API</h1>
</header>

<section>
    <h2>Building the Application</h2>
    <p>Building reliable, scalable applications is a key goal for developers. One of the most effective ways to achieve this is by implementing a CI/CD (Continuous Integration/Continuous Deployment) pipeline. In this post, I’ll walk you through my journey of developing the Gemini API, testing it, and setting up an automated CI/CD pipeline using GitHub Actions. Along the way, I’ll explain how these tools streamline the development process and ensure that everything works seamlessly.</p>
</section>

<section>
    <h2>Setting Up the Gemini API</h2>
    <p>The Gemini API I created serves as a simple interface for generating content based on user-provided prompts and instructions. The API is built using Flask, a lightweight Python framework that’s perfect for quick, simple applications.</p>
    <p>Here’s a quick look at the core function that handles incoming requests:</p>
    
    <pre><code>@app.route('/generate', methods=['POST'])
def generate_content():
    data = request.get_json()
    prompt = data.get("prompt")
    instructions = data.get("instructions")
    response = f"This is a mock response based on the prompt: '{prompt}' with instructions: '{instructions}'."
    return jsonify({"response": response})</code></pre>
</section>

<section>
    <h2>Testing the API Locally</h2>
    <p>To test it locally, I used curl, a simple command-line tool that allows you to send HTTP requests.</p>
    <pre><code>curl -X POST http://localhost:5000/generate \
-H "Content-Type: application/json" \
-d "{\"prompt\": \"Write a blog post introduction\", \"instructions\": \"Make it formal and concise.\"}"</code></pre>
    <p>Response:</p>
    <pre><code>{
  "response": "This is a mock response based on the prompt: 'Write a blog post introduction' with instructions: 'Make it formal and concise.'"
}</code></pre>
</section>

<section>
    <h2>Setting Up CI/CD with GitHub Actions</h2>
    <p>The next step was to automate the testing and integration with GitHub Actions. CI/CD pipelines are essential for automating the testing, building, and deployment processes.</p>
    <pre><code>name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        run: |
          docker build -t gemini-api .

      - name: Run tests (mocked for now)
        run: |
          echo "Mock testing skipped for now"

      - name: Deploy to production (optional)
        run: |
          echo "Deploying the app..."</code></pre>
</section>

<section>
    <h2>Challenges and Solutions</h2>
    <p>While setting up the pipeline, I encountered a few hurdles:</p>
    <ul>
        <li>Running Docker in CI/CD was a challenge due to networking issues.</li>
        <li>Testing in Docker required mimicking the local setup accurately.</li>
    </ul>
</section>

<section>
    <h2>Conclusion</h2>
    <p>This project provided valuable experience in working with APIs, Docker, and CI/CD pipelines. Improvements to be made include running real tests inside the CI/CD pipeline and expanding the pipeline for cloud deployment.</p>
</section>

<footer>
    <p>&copy; 2023 Your Name. All rights reserved.</p>
</footer>

</body>
</html>
