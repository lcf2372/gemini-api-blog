<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Abinesh Pandi">
    <title>Exploring CI/CD and API Testing with the Gemini API</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        header {
            background-color: #4CAF50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            margin: 0;
        }

        article {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #333;
        }

        h3 {
            margin-top: 20px;
            color: #555;
        }

        code {
            background-color: #f4f4f4;
            padding: 5px;
            font-family: Consolas, monospace;
            border-radius: 5px;
        }

        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1rem;
        }

        pre code {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            margin-top: 20px;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            font-size: 0.9rem;
            color: #555;
        }

        .code-example {
            background-color: #eeeeee;
            border-left: 5px solid #4CAF50;
            padding: 10px;
            margin: 20px 0;
        }

        .repository-link {
            text-align: center;
            margin-top: 30px;
            font-size: 1.1rem;
        }

        .repository-link a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }

        .repository-link a:hover {
            text-decoration: underline;
        }

        .cicd-image {
        max-width: 100%;
        height: auto;
        border-radius: 5px;
        margin-top: 20px;
        display: block;
        margin-left: auto;
        margin-right: auto;
        }
    </style>
</head>
<body>

    <header>
        <h1>Exploring CI/CD and API Testing with the Gemini API</h1>
    </header>

    <article>
        <p>Building reliable, scalable applications is a key goal for developers, and one of the most effective ways to achieve this is by implementing a CI/CD (Continuous Integration/Continuous Deployment) pipeline. In this post, I’ll walk you through my journey of developing the Gemini API, testing it, and setting up an automated CI/CD pipeline using GitHub Actions. Along the way, I’ll explain how these tools streamline the development process and ensure that everything works seamlessly.</p>

        <h2>Setting Up the Gemini API</h2>
        <p>The Gemini API I created serves as a simple interface for generating content based on user-provided prompts and instructions. The idea behind the API is simple: users send a request with a prompt, and the API responds with a mock result based on that prompt. This allows for easy testing and showcases how APIs can be used to generate content programmatically.</p>
        <p>The API is built using Flask, a lightweight Python framework that’s perfect for quick, simple applications. We’ve set up a POST endpoint at <code>/generate</code> that accepts two pieces of information from users: a prompt and instructions. Based on this input, the API sends back a response with the processed data.</p>

        <h3>Here’s a quick look at the core function that handles incoming requests:</h3>
        <pre><code>@app.route('/generate', methods=['POST'])
def generate_content():
    data = request.get_json()
    prompt = data.get("prompt")
    instructions = data.get("instructions")
    response = f"This is a mock response based on the prompt: '{prompt}' with instructions: '{instructions}'."
    return jsonify({"response": response})</code></pre>

        <h2>Testing the API Locally</h2>
        <p>Before diving into the CI/CD setup, it’s crucial to make sure the API works as expected. To test it locally, I used <code>curl</code>, a simple yet powerful command-line tool that allows you to send HTTP requests and view responses.</p>
        <p>For example, I used the following curl command to send a POST request to the <code>/generate</code> endpoint:</p>

        <pre><code>curl -X POST http://localhost:5000/generate \
-H "Content-Type: application/json" \
-d "{\"prompt\": \"Write a blog post introduction\", \"instructions\": \"Make it formal and concise.\"}"</code></pre>
        <div class="code-example">
            <p>Response:</p>
            <pre><code>{
  "response": "This is a mock response based on the prompt: 'Write a blog post introduction' with instructions: 'Make it formal and concise.'"
}</code></pre>
        </div>
        <p>This gave me a mock response, proving that the basic functionality was in place.</p>

        <h2>Setting Up CI/CD with GitHub Actions</h2>
        <p>Once the API was working locally, the next step was to automate testing and integration with GitHub Actions. CI/CD pipelines are essential for automating the testing, building, and deployment processes. With GitHub Actions, I set up a pipeline that automatically triggers whenever changes are pushed to the repository.</p>
        <p>The pipeline is configured to do the following:</p>
        <ul>
            <li>Build the Docker Image: Docker ensures that the API runs the same way on any machine, eliminating environment inconsistencies.</li>
            <li>Run Tests: Although I’ve mocked the actual tests in the pipeline for now, this step will eventually run unit and integration tests automatically.</li>
            <li>CI/CD Automation: The entire process is automated — no more manual testing or deployment steps.</li>
        </ul>
        <p>Here’s what the pipeline configuration looks like in the GitHub Actions workflow file:</p>

        <pre><code>name: CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        run: |
          docker build -t gemini-api .

      - name: Run tests (mocked for now)
        run: |
          echo "Mock testing skipped for now"

      - name: Deploy to production (optional)
        run: |
          echo "Deploying the app..."</code></pre>

        <h2>Challenges and Solutions</h2>
        <p>While setting up the pipeline, I encountered a few hurdles that required some problem-solving:</p>
        <ul>
            <li><strong>Running Docker in CI/CD:</strong> One challenge I faced was getting Docker to run properly inside the GitHub Actions environment. Docker containers are essential for this project, and initially, I had trouble with networking and connectivity between the containers.</li>
            <li><strong>Testing in Docker:</strong> Running API tests inside Docker was tricky because I needed to ensure the containerized environment mimicked the local setup accurately. For now, I’ve opted to mock the tests, but I plan to revisit this to fully automate the test process inside Docker.</li>
        </ul>

        <h2>Conclusion</h2>
        <p>In summary, this project provided valuable experience in working with APIs, Docker, and CI/CD pipelines. By integrating these tools, I was able to automate the process of testing and building the Gemini API, saving time and reducing the risk of human error.</p>
        <p>Looking forward, there are several improvements to be made:</p>
        <ul>
            <li>Running real tests inside the CI/CD pipeline (after resolving Docker-related issues).</li>
            <li>Expanding the pipeline to deploy the application to a cloud platform like Heroku or AWS.</li>
        </ul>
        <p>CI/CD pipelines are a crucial part of modern development workflows, and by automating these steps, we can ensure faster, more reliable software delivery.</p>

        <!-- Repository Link -->
        <div class="repository-link">
            <p>Check out the source code for this project on GitHub: <a href="https://github.com/lcf2372/gemini-api" target="_blank">Gemini API Repository</a></p>
        </div>

        <!-- CI/CD Image -->
        <img src="https://github.com/lcf2372/gemini-api-blog/blob/gh-pages/CI-CD.png?raw=true" alt="CI/CD Pipeline" class="cicd-image">
    </article>

    <footer class="footer">
        <p>&copy; 2024 Abinesh Pandi. All rights reserved.</p>
    </footer>

</body>
</html>
